# Task #6: Create Dynamic Count System and Alpine.js Data Binding

**Epic**: Enhanced Grove Headbar  
**Phase**: Component Enhancement  
**Estimated Effort**: 6-8 hours  
**Dependencies**: Task #5  

## Objective
Implement real-time count displays for navigation tabs and create proper Alpine.js data binding for dynamic updates in the enhanced Grove headbar.

## Scope
- Connect Django context count data to Alpine.js reactive system
- Implement real-time count updates without page refresh
- Create count badge components with proper styling
- Add WebSocket or polling mechanism for live count updates

## Deliverables
- [ ] Alpine.js reactive count data binding
- [ ] Real-time count update mechanism
- [ ] Styled count badges matching existing design
- [ ] Performance-optimized update strategy

## Technical Details
### Alpine.js Count Data Structure
```javascript
// WaveHeadbar Alpine.js data enhancement
countsData: {
    workspaces: 0,
    datasources: 0,
    experiments: 0,
    lastUpdated: null,
    updateInterval: 30000, // 30 seconds
    isUpdating: false
},

// Methods for count management
updateCounts() {
    this.isUpdating = true;
    fetch('/api/headbar/counts/')
        .then(response => response.json())
        .then(data => {
            this.countsData.workspaces = data.workspaces;
            this.countsData.datasources = data.datasources;
            this.countsData.experiments = data.experiments;
            this.countsData.lastUpdated = new Date();
        })
        .finally(() => {
            this.isUpdating = false;
        });
}
```

### Backend Count API
```python
# core/api.py
@login_required
def headbar_counts_api(request):
    """API endpoint for real-time headbar counts"""
    user = request.user
    counts = {
        'workspaces': Project.objects.filter(owner=user).count(),
        'datasources': DataSource.objects.filter(project__owner=user).count(),
        'experiments': MLExperiment.objects.filter(project__owner=user).count(),
        'timestamp': timezone.now().isoformat()
    }
    return JsonResponse(counts)
```

### Count Badge Styling
- Use existing classes: `bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 text-xs px-2 py-1 rounded-full`
- Implement smooth transition animations for count changes
- Handle edge cases (0 counts, large numbers >999)
- Support for loading states during updates

### Update Strategy Options
1. **Polling**: Regular API calls every 30 seconds
2. **WebSocket**: Real-time updates via Django Channels
3. **Event-driven**: Updates triggered by user actions
4. **Hybrid**: Polling with event-driven optimization

## Acceptance Criteria
- [ ] Count badges display current accurate data from Django context
- [ ] Counts update automatically without page refresh
- [ ] Count changes animate smoothly (fade/scale transitions)
- [ ] API endpoint responds within 100ms average
- [ ] Count updates don't interfere with user interactions
- [ ] Handles network failures gracefully with fallback to cached counts
- [ ] Large numbers (>999) display appropriately (e.g., "1.2k")

## Implementation Notes
- Implement caching strategy for count data to reduce database load
- Consider using Redis for real-time count storage
- Add proper error handling and retry logic for API failures
- Test count accuracy during high-frequency content creation/deletion
- Ensure count updates work properly across multiple browser tabs
- Monitor performance impact of real-time updates on overall application