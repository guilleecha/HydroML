# Task #20: Django Template Integration and Context Processors

## Objective
Integrate the Wave theme system and component library seamlessly into Django's template system through custom template tags, context processors, and enhanced template inheritance patterns that make components easily accessible to developers.

## Scope
Create the Django-side infrastructure that bridges the frontend component library with Django's template rendering system, enabling efficient component usage and theme management across all HydroML applications.

## Detailed Deliverables

### 1. Custom Template Tags
- **Component Tags**: Template tags for rendering Wave components with Django data
- **Theme Tags**: Template tags for theme-aware rendering and configuration
- **Asset Tags**: Intelligent loading of component assets and dependencies
- **Conditional Tags**: Theme-aware conditional rendering based on user preferences

### 2. Context Processors
- **Theme Context**: Global theme configuration and user preferences
- **Component Context**: Available components and their configurations
- **Navigation Context**: Dynamic navigation data based on user permissions
- **Asset Context**: Optimized asset loading based on page requirements

### 3. Template Tag Library
- **wave_component**: Render individual Wave components with properties
- **wave_form**: Enhanced form rendering with Wave form components
- **wave_layout**: Layout helpers for consistent page structure
- **wave_theme**: Theme utilities for conditional rendering and configuration
- **wave_assets**: Smart asset inclusion based on component usage

### 4. Enhanced Template Inheritance
- **Component Base Templates**: Base templates optimized for component usage
- **Block Extensions**: Additional template blocks for component integration
- **Asset Management**: Automatic asset dependency resolution
- **Performance Optimization**: Minimize template rendering overhead

## Acceptance Criteria

### Functional Requirements
- [ ] Template tags render components correctly with Django model data
- [ ] Context processors provide theme and navigation data to all templates
- [ ] Asset management automatically includes required CSS/JS for used components
- [ ] Template inheritance supports component-based page construction
- [ ] Form integration works seamlessly with Django forms and validation

### Quality Standards
- [ ] Template tags follow Django conventions and best practices
- [ ] Error handling provides clear feedback for invalid component usage
- [ ] Documentation covers all template tags with usage examples
- [ ] Context processors are performant and don't impact page load times
- [ ] Template tags are testable and maintainable

### Performance Criteria
- [ ] Context processor overhead <10ms per request
- [ ] Template tag rendering adds <5ms per component
- [ ] Asset loading optimized to prevent unnecessary downloads
- [ ] Template caching works correctly with component system

## Technical Specifications

### File Structure
```
hydroml/
├── templatetags/
│   ├── __init__.py
│   ├── wave_components.py
│   ├── wave_theme.py
│   ├── wave_forms.py
│   └── wave_assets.py
├── context_processors/
│   ├── __init__.py
│   ├── theme_context.py
│   ├── navigation_context.py
│   └── component_context.py
└── utils/
    ├── component_loader.py
    ├── asset_manager.py
    └── theme_utils.py
```

### Template Tag Implementation
```python
# wave_components.py
from django import template
from django.utils.safestring import mark_safe
from ..utils.component_loader import ComponentLoader

register = template.Library()

@register.inclusion_tag('components/wave_button.html', takes_context=True)
def wave_button(context, text, variant='primary', size='md', **kwargs):
    """Render a Wave button component with specified properties."""
    return {
        'text': text,
        'variant': variant,
        'size': size,
        'attributes': kwargs,
        'theme': context.get('theme', {}),
        'request': context.get('request')
    }

@register.simple_tag(takes_context=True)
def wave_component(context, component_name, **kwargs):
    """Generic component renderer for any Wave component."""
    loader = ComponentLoader()
    component_config = loader.get_component_config(component_name)
    
    if not component_config:
        raise template.TemplateSyntaxError(f"Unknown component: {component_name}")
    
    return loader.render_component(
        component_name, 
        context=context, 
        props=kwargs
    )

@register.filter
def theme_class(value, theme_property):
    """Apply theme-aware CSS classes based on current theme."""
    theme = template.context_processors.theme_context(None)['theme']
    return f"{value} {theme.get_class(theme_property)}"
```

### Context Processor Implementation
```python
# theme_context.py
from django.conf import settings
from ..models import UserThemePreference
from ..utils.theme_utils import ThemeManager

def theme_context(request):
    """Provide theme configuration and user preferences to all templates."""
    theme_manager = ThemeManager()
    
    # Get user theme preference
    user_theme = 'auto'
    if request.user.is_authenticated:
        try:
            preference = UserThemePreference.objects.get(user=request.user)
            user_theme = preference.theme
        except UserThemePreference.DoesNotExist:
            pass
    
    # Get theme configuration
    theme_config = theme_manager.get_theme_config(user_theme)
    
    return {
        'theme': {
            'current': user_theme,
            'config': theme_config,
            'available_themes': theme_manager.get_available_themes(),
            'system_theme': theme_manager.detect_system_theme(request),
        },
        'theme_assets': theme_manager.get_required_assets(user_theme)
    }

# navigation_context.py
def navigation_context(request):
    """Provide navigation data based on user permissions and current page."""
    from ..utils.navigation_builder import NavigationBuilder
    
    nav_builder = NavigationBuilder()
    navigation = nav_builder.build_navigation(request.user, request.path)
    
    return {
        'navigation': navigation,
        'breadcrumbs': nav_builder.build_breadcrumbs(request.path),
        'current_section': nav_builder.get_current_section(request.path)
    }
```

### Enhanced Form Integration
```python
# wave_forms.py
from django import template
from django.forms.widgets import Widget
from ..widgets import WaveWidget

register = template.Library()

@register.inclusion_tag('forms/wave_form.html', takes_context=True)
def wave_form(context, form, layout='vertical', **kwargs):
    """Render a Django form using Wave form components."""
    return {
        'form': form,
        'layout': layout,
        'form_config': kwargs,
        'theme': context.get('theme', {}),
        'request': context.get('request')
    }

@register.inclusion_tag('forms/wave_field.html', takes_context=True)
def wave_field(context, field, **kwargs):
    """Render a single form field using Wave input components."""
    widget_type = field.field.widget.__class__.__name__.lower()
    wave_component = get_wave_component_for_widget(widget_type)
    
    return {
        'field': field,
        'component': wave_component,
        'field_config': kwargs,
        'theme': context.get('theme', {}),
    }

class WaveWidget(Widget):
    """Base widget class for Wave component integration."""
    template_name = 'widgets/wave_widget.html'
    component_name = None
    
    def __init__(self, component_name=None, **kwargs):
        self.component_name = component_name or self.component_name
        super().__init__(**kwargs)
    
    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        context['component_name'] = self.component_name
        context['component_props'] = self.get_component_props(name, value, attrs)
        return context
    
    def get_component_props(self, name, value, attrs):
        """Override to provide component-specific properties."""
        return {
            'name': name,
            'value': value,
            'attributes': attrs
        }
```

### Asset Management
```python
# wave_assets.py
from django import template
from django.utils.safestring import mark_safe
from ..utils.asset_manager import AssetManager

register = template.Library()

@register.simple_tag(takes_context=True)
def wave_assets(context, asset_type='auto'):
    """Include required Wave assets based on page component usage."""
    asset_manager = AssetManager()
    
    if asset_type == 'auto':
        # Analyze template context to determine required assets
        required_assets = asset_manager.analyze_required_assets(context)
    else:
        required_assets = asset_manager.get_assets_for_type(asset_type)
    
    return mark_safe(asset_manager.render_asset_tags(required_assets))

@register.simple_tag
def wave_component_styles():
    """Include component-specific CSS."""
    asset_manager = AssetManager()
    return mark_safe(asset_manager.get_component_styles())

@register.simple_tag
def wave_component_scripts():
    """Include component-specific JavaScript."""
    asset_manager = AssetManager()
    return mark_safe(asset_manager.get_component_scripts())
```

## Dependencies
- Wave component library (Task #19)
- Runtime theme configuration (Task #18)
- Layout patterns and templates (Task #17)
- Django template system
- Django forms framework
- User authentication system

## Integration Points
- Django settings configuration
- Static file management
- User preference storage
- Component registration system
- Template caching system

## Estimated Effort
**12-16 hours** over 4-5 days
- Template tag development: 5 hours
- Context processor implementation: 3 hours
- Form integration and widgets: 4 hours
- Asset management system: 3 hours
- Testing and optimization: 2-3 hours
- Documentation and examples: 3 hours

## Definition of Done
- Template tags provide easy component integration
- Context processors supply theme and navigation data efficiently
- Form integration works seamlessly with Django forms
- Asset management optimizes component loading
- Comprehensive documentation with usage examples
- Performance benchmarks met for all integrations
- Code reviewed and tested thoroughly
- Integration testing with existing HydroML modules complete